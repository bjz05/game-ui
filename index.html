<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Character Select</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Rajdhani', 'Segoe UI', sans-serif;
    background: #f0f0f2;
    color: #1a1a1e;
    height: 100vh;
    overflow: hidden;
    user-select: none;
  }

  /* ─── Root Layout ─── */
  .layout {
    display: flex;
    width: 100%; height: 100vh;
    transition: opacity 0.3s;
  }

  /* ─── Left Panel ─── */
  .panel-left {
    flex: 0 0 300px;
    height: 100vh;
    display: flex;
    flex-direction: column;
    background: #ffffff;
    border-right: 1px solid #e2e2e5;
    overflow: hidden;
    transition: flex-basis 0.4s cubic-bezier(.4,0,.2,1), opacity 0.35s;
  }
  .panel-left.hidden {
    flex-basis: 0;
    opacity: 0;
    pointer-events: none;
  }

  .panel-left .panel-title {
    padding: 24px 20px 10px;
    flex-shrink: 0;
  }
  .panel-left .panel-title h1 {
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: #999;
  }
  .panel-left .panel-title h2 {
    font-size: 22px;
    font-weight: 700;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #1a1a1e;
    margin-top: 2px;
  }

  /* Scrollable card list */
  .card-list {
    flex: 1;
    overflow-y: auto;
    padding: 6px 14px 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    scrollbar-width: thin;
    scrollbar-color: #ccc transparent;
  }
  .card-list::-webkit-scrollbar { width: 4px; }
  .card-list::-webkit-scrollbar-track { background: transparent; }
  .card-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 2px; }

  /* ─── Game-Style Portrait Card ─── */
  .char-card {
    flex-shrink: 0;
    position: relative;
    height: 220px;
    border-radius: 12px;
    overflow: hidden;
    border: 2px solid #e0e0e3;
    background: #1a1a1e;
    cursor: pointer;
    transition: border-color 0.25s, box-shadow 0.25s, transform 0.2s;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
  }
  .char-card:hover {
    border-color: #b0b0b5;
    transform: scale(1.02);
    box-shadow: 0 4px 14px rgba(0,0,0,0.1);
  }
  .char-card.active {
    border-color: #4a9eff;
    box-shadow: 0 0 0 2px rgba(74,158,255,0.25), 0 4px 18px rgba(74,158,255,0.2);
    transform: scale(1.03);
  }

  /* Full-bleed background image */
  .card-bg {
    position: absolute;
    inset: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    object-position: top center;
  }

  /* Dark gradient overlay — bottom 60% of card */
  .card-gradient {
    position: absolute;
    inset: 0;
    background: linear-gradient(
      to bottom,
      transparent 20%,
      rgba(20,20,24,0.3) 42%,
      rgba(20,20,24,0.72) 60%,
      rgba(20,20,24,0.92) 100%
    );
  }

  /* Info layer on top */
  .card-info {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    padding: 0 14px 12px;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    height: 65%;
  }

  .card-name {
    font-size: 17px;
    font-weight: 700;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: #fff;
    text-shadow: 0 1px 4px rgba(0,0,0,0.4);
    line-height: 1.2;
  }
  .char-card.active .card-name {
    text-shadow: 0 0 12px rgba(74,158,255,0.5), 0 1px 4px rgba(0,0,0,0.4);
  }

  .card-role {
    font-size: 9px;
    font-weight: 600;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.55);
    margin-top: 2px;
    margin-bottom: 8px;
  }

  /* Stat bars */
  .card-stats {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .stat-bar-row {
    display: flex;
    align-items: center;
    gap: 7px;
  }
  .stat-bar-label {
    font-size: 8px;
    font-weight: 600;
    letter-spacing: 1px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.5);
    width: 52px;
    flex-shrink: 0;
  }
  .stat-bar-track {
    flex: 1;
    height: 4px;
    background: rgba(255,255,255,0.12);
    border-radius: 2px;
    overflow: hidden;
  }
  .stat-bar-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.6s cubic-bezier(.4,0,.2,1);
  }
  .stat-bar-fill.armor   { background: #5b8dd9; }
  .stat-bar-fill.mobility { background: #5dba6e; }
  .stat-bar-fill.health  { background: #e05a5a; }
  .stat-bar-fill.power   { background: #e89a3c; }

  /* ─── Right Panel: 3D Viewer ─── */
  .panel-right {
    flex: 1;
    height: 100vh;
    position: relative;
    overflow: hidden;
    background: linear-gradient(180deg, #e8e8ea 0%, #f4f4f6 40%, #ffffff 100%);
  }

  #viewer-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    cursor: grab;
  }
  #viewer-canvas:active { cursor: grabbing; }

  /* Subtle ground reflection line */
  .ground-line {
    position: absolute;
    bottom: 28%;
    left: 5%; right: 5%;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(0,0,0,0.06), transparent);
    pointer-events: none;
    z-index: 2;
  }

  /* Bottom info bar */
  .viewer-info {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    padding: 24px 40px 32px;
    z-index: 5;
    display: flex;
    align-items: flex-end;
    justify-content: space-between;
    transition: transform 0.4s cubic-bezier(.4,0,.2,1), opacity 0.35s;
  }
  .viewer-info.hidden {
    transform: translateY(30px);
    opacity: 0;
    pointer-events: none;
  }
  .viewer-info .info-left .info-name {
    font-size: 32px;
    font-weight: 700;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #1a1a1e;
  }
  .viewer-info .info-left .info-role {
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 2.5px;
    text-transform: uppercase;
    color: #999;
    margin-top: 3px;
  }

  /* Select button */
  .select-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 11px 32px;
    background: #1a1a1e;
    border: none;
    border-radius: 24px;
    color: #fff;
    font-family: inherit;
    font-size: 12px;
    font-weight: 700;
    letter-spacing: 2.5px;
    text-transform: uppercase;
    cursor: pointer;
    transition: background 0.2s, box-shadow 0.2s, transform 0.12s;
    box-shadow: 0 2px 10px rgba(0,0,0,0.15);
  }
  .select-btn:hover { background: #333; box-shadow: 0 4px 16px rgba(0,0,0,0.2); }
  .select-btn:active { transform: scale(0.96); }
  .select-btn kbd {
    display: inline-flex; align-items: center; justify-content: center;
    width: 20px; height: 20px;
    border-radius: 4px;
    border: 1px solid rgba(255,255,255,0.25);
    background: rgba(255,255,255,0.1);
    font-size: 10px; color: rgba(255,255,255,0.6); font-family: inherit;
  }

  /* Key hint top-right */
  .hint-row {
    position: absolute;
    top: 20px; right: 28px;
    z-index: 5;
    font-size: 10px;
    letter-spacing: 1.5px;
    color: #bbb;
    text-transform: uppercase;
    transition: opacity 0.3s;
  }
  .hint-row.hidden { opacity: 0; pointer-events: none; }
  .hint-row kbd {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid #ddd;
    background: #fff;
    color: #666;
    font-family: inherit;
    font-size: 9px;
    margin: 0 1px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.06);
  }

  /* Drag hint */
  .drag-hint {
    position: absolute;
    top: 20px; left: 50%;
    transform: translateX(-50%);
    z-index: 5;
    font-size: 10px;
    letter-spacing: 1.5px;
    color: #bbb;
    text-transform: uppercase;
    pointer-events: none;
    transition: opacity 0.4s;
  }
  .drag-hint.hidden { opacity: 0; }

  /* Loading spinner */
  .viewer-loader {
    position: absolute;
    inset: 0; z-index: 4;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    transition: opacity 0.4s;
  }
  .viewer-loader.hidden { opacity: 0; }
  .viewer-loader .spinner-ring {
    width: 36px; height: 36px;
    border: 2px solid #ddd;
    border-top-color: #1a1a1e;
    border-radius: 50%;
    animation: spin 0.7s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .viewer-loader .loader-text {
    margin-top: 12px;
    font-size: 10px;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: #aaa;
  }

  /* ─── Flash overlay ─── */
  .flash-overlay {
    position: fixed; inset: 0; z-index: 100;
    background: rgba(255,255,255,0.85);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s ease-out;
  }
  .flash-overlay.show { opacity: 1; }

  /* ─── Celebration Overlay ─── */
  .celebration-overlay {
    position: fixed; inset: 0; z-index: 200;
    background: rgba(10,10,14,0.75);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.5s cubic-bezier(.4,0,.2,1);
  }
  .celebration-overlay.show {
    opacity: 1;
    pointer-events: auto;
  }

  .celebration-name {
    font-size: 56px;
    font-weight: 700;
    letter-spacing: 6px;
    text-transform: uppercase;
    color: #fff;
    text-shadow: 0 0 40px rgba(74,158,255,0.4), 0 2px 8px rgba(0,0,0,0.5);
    display: flex;
    overflow: hidden;
  }
  .celebration-name .letter {
    display: inline-block;
    opacity: 0;
    transform: translateY(28px);
    animation: celebLetter 0.5s cubic-bezier(.4,0,.2,1) forwards;
  }
  @keyframes celebLetter {
    to { opacity: 1; transform: translateY(0); }
  }

  .celebration-role {
    font-size: 13px;
    font-weight: 600;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.5);
    margin-top: 10px;
    opacity: 0;
    animation: celebFadeIn 0.4s 0.05s cubic-bezier(.4,0,.2,1) forwards;
  }

  .celebration-line {
    width: 48px;
    height: 1px;
    background: rgba(74,158,255,0.6);
    margin-top: 18px;
    opacity: 0;
    animation: celebFadeIn 0.4s 0.3s cubic-bezier(.4,0,.2,1) forwards;
  }

  .celebration-label {
    font-size: 9px;
    font-weight: 600;
    letter-spacing: 5px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.35);
    margin-top: 10px;
    opacity: 0;
    animation: celebFadeIn 0.4s 0.5s cubic-bezier(.4,0,.2,1) forwards;
  }

  @keyframes celebFadeIn {
    to { opacity: 1; }
  }

  .celebration-dismiss {
    position: absolute;
    bottom: 60px;
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.3);
    opacity: 0;
    animation: celebFadeIn 0.4s 1.2s cubic-bezier(.4,0,.2,1) forwards;
  }
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
    "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/loaders/GLTFLoader.js"
  }
}
</script>
</head>
<body>

<div class="flash-overlay" id="flash"></div>

<div class="celebration-overlay" id="celebOverlay">
  <div class="celebration-name" id="celebName"></div>
  <div class="celebration-role" id="celebRole"></div>
  <div class="celebration-line"></div>
  <div class="celebration-label">Selected</div>
  <div class="celebration-dismiss">Click anywhere to continue</div>
</div>

<div class="layout">

  <!-- LEFT -->
  <div class="panel-left" id="panelLeft">
    <div class="panel-title">
      <h1>Player One</h1>
      <h2>Characters</h2>
    </div>
    <div class="card-list" id="cardList"></div>
  </div>

  <!-- RIGHT -->
  <div class="panel-right">
    <canvas id="viewer-canvas"></canvas>
    <div class="ground-line"></div>

    <div class="viewer-loader" id="viewerLoader">
      <div class="spinner-ring"></div>
      <div class="loader-text">Loading</div>
    </div>

    <div class="drag-hint" id="dragHint">Drag to rotate</div>

    <div class="hint-row" id="hintRow">
      <kbd>↑</kbd> <kbd>↓</kbd> navigate &nbsp;·&nbsp; <kbd>Enter</kbd> select
    </div>

    <div class="viewer-info" id="viewerInfo">
      <div class="info-left">
        <div class="info-name" id="infoName"></div>
        <div class="info-role" id="infoRole"></div>
      </div>
      <button class="select-btn" id="selectBtn">Select <kbd>↵</kbd></button>
    </div>
  </div>
</div>

<script>
// importmap + ES modules don't work on file:// — show a helper
if (location.protocol === 'file:') {
  document.body.innerHTML = `
    <div style="
      height:100vh; display:flex; align-items:center; justify-content:center;
      background:#1a1a1e; font-family:'Segoe UI',sans-serif; color:#fff;
    ">
      <div style="max-width:520px; text-align:center; padding:0 24px;">
        <div style="font-size:40px; margin-bottom:16px;">⚠️</div>
        <h2 style="font-size:20px; font-weight:600; margin-bottom:10px; letter-spacing:1px;">
          Needs a Local Server
        </h2>
        <p style="font-size:14px; color:rgba(255,255,255,0.55); line-height:1.6; margin-bottom:24px;">
          This page uses ES modules which browsers block on <code style="background:rgba(255,255,255,0.1);padding:2px 6px;border-radius:4px;font-size:13px;">file://</code>.
          Run a quick local server from the <strong>Animations</strong> folder:
        </p>
        <div style="background:rgba(255,255,255,0.07); border-radius:10px; padding:16px 20px; text-align:left; margin-bottom:24px;">
          <div style="font-size:11px; color:rgba(255,255,255,0.35); letter-spacing:1px; text-transform:uppercase; margin-bottom:8px;">Terminal</div>
          <code style="font-size:14px; color:#7dd3fc; white-space:pre-wrap;">cd ~/Desktop/Animations<br>python3 -m http.server 8765</code>
        </div>
        <p style="font-size:13px; color:rgba(255,255,255,0.4);">
          Then open <strong style="color:#7dd3fc;">http://localhost:8765</strong> in this browser.
        </p>
      </div>
    </div>`;
}
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

/* ─── Data ─── */
const GLB_BASE = 'https://github.com/bjz05/blade-throne/releases/download/v1.0.0/';

const characters = [
  {
    name: "Iron Knight",
    role: "Armored Defender",
    glb: GLB_BASE + "f234f6327ec2ffb363665b304289ac45.glb",
    thumb: "Benjamin_Zhou_a_full_body_knight_front_view_--chaos_65_--sref_03ad4f0d-c375-495c-bba4-e93ef333a217_2.png",
    stats: { armor: "HIGH", mobility: "LOW", health: "HIGH", power: "MED" },
    bb: { min: [-0.337, 0, -0.147], max: [0.336, 1.088, 0.198] }
  },
  {
    name: "Wind Dancer",
    role: "Free-Spirit Blade",
    glb: GLB_BASE + "1b3334743b8d7787228258de0357c9b0.glb",
    thumb: "Benjamin_Zhou_a_free_and_easy_swordsman_front_view_full_body__2c075ea2-c60f-4f90-98e9-3f63175f3d27_3.png",
    stats: { armor: "LOW", mobility: "HIGH", health: "MED", power: "MED" },
    bb: { min: [-0.313, 0, -0.328], max: [0.294, 1.177, 0.418] }
  },
  {
    name: "Cyber Ronin",
    role: "Shadow Striker",
    glb: GLB_BASE + "e7a067c01e2b943a30d4b6b07245f251.glb",
    thumb: "Benjamin_Zhou_cyberpunk_world_swordsman_full_body_head_to_fee_8b26e4ec-ee06-4ffe-80f3-22e546f0dc9e_3.png",
    stats: { armor: "MED", mobility: "HIGH", health: "MED", power: "HIGH" },
    bb: { min: [-0.346, 0, -0.159], max: [0.326, 1.175, 0.197] }
  }
];

const STAT_PCT = { LOW: 33, MED: 66, HIGH: 100 };

let current = 0;

/* ─── DOM ─── */
const cardList      = document.getElementById('cardList');
const viewerLoader  = document.getElementById('viewerLoader');
const infoName      = document.getElementById('infoName');
const infoRole      = document.getElementById('infoRole');
const flash         = document.getElementById('flash');
const panelLeft     = document.getElementById('panelLeft');
const viewerInfo    = document.getElementById('viewerInfo');
const hintRow       = document.getElementById('hintRow');
const dragHint      = document.getElementById('dragHint');
const celebOverlay  = document.getElementById('celebOverlay');
const celebName     = document.getElementById('celebName');
const celebRole     = document.getElementById('celebRole');

/* ─── Build portrait cards ─── */
characters.forEach((ch, i) => {
  const card = document.createElement('div');
  card.className = 'char-card' + (i === 0 ? ' active' : '');
  card.id = 'card-' + i;
  card.innerHTML = `
    <img class="card-bg" src="${ch.thumb}" alt="${ch.name}" />
    <div class="card-gradient"></div>
    <div class="card-info">
      <div class="card-name">${ch.name}</div>
      <div class="card-role">${ch.role}</div>
      <div class="card-stats">
        <div class="stat-bar-row">
          <span class="stat-bar-label">Armor</span>
          <div class="stat-bar-track"><div class="stat-bar-fill armor" style="width:${STAT_PCT[ch.stats.armor]}%"></div></div>
        </div>
        <div class="stat-bar-row">
          <span class="stat-bar-label">Mobility</span>
          <div class="stat-bar-track"><div class="stat-bar-fill mobility" style="width:${STAT_PCT[ch.stats.mobility]}%"></div></div>
        </div>
        <div class="stat-bar-row">
          <span class="stat-bar-label">Health</span>
          <div class="stat-bar-track"><div class="stat-bar-fill health" style="width:${STAT_PCT[ch.stats.health]}%"></div></div>
        </div>
        <div class="stat-bar-row">
          <span class="stat-bar-label">Power</span>
          <div class="stat-bar-track"><div class="stat-bar-fill power" style="width:${STAT_PCT[ch.stats.power]}%"></div></div>
        </div>
      </div>
    </div>
  `;
  card.addEventListener('click', () => goTo(i));
  cardList.appendChild(card);
});

/* ─── Three.js setup ─── */
const canvas   = document.getElementById('viewer-canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();

// Studio lighting — store references for celebration animation
const keyLight = new THREE.DirectionalLight(0xffffff, 1.6);
keyLight.position.set(2, 4, 3);
scene.add(keyLight);

const fillLight = new THREE.DirectionalLight(0xffffff, 0.8);
fillLight.position.set(-3, 2, 1);
scene.add(fillLight);

const rimLight = new THREE.DirectionalLight(0xffffff, 0.4);
rimLight.position.set(0, 1, -3);
scene.add(rimLight);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

// Original light state (for restoration after celebration)
const LIGHTS_DEFAULT = {
  key:     { intensity: 1.6, pos: new THREE.Vector3(2, 4, 3), color: new THREE.Color(0xffffff) },
  fill:    { intensity: 0.8, pos: new THREE.Vector3(-3, 2, 1), color: new THREE.Color(0xffffff) },
  rim:     { intensity: 0.4, pos: new THREE.Vector3(0, 1, -3), color: new THREE.Color(0xffffff) },
  ambient: { intensity: 0.6 }
};

// Camera
const panelEl = canvas.parentElement;
const camera = new THREE.PerspectiveCamera(40, panelEl.clientWidth / panelEl.clientHeight, 0.1, 100);
camera.position.set(0, 0.6, 3);
camera.lookAt(0, 0.6, 0);

resizeRenderer();

/* ─── Models ─── */
const models = [null, null, null];
const loader = new GLTFLoader();

function resizeRenderer() {
  const p = canvas.parentElement;
  renderer.setSize(p.clientWidth, p.clientHeight);
  camera.aspect = p.clientWidth / p.clientHeight;
  camera.updateProjectionMatrix();
}

/* ─── Orbit state ─── */
let orbitTarget   = new THREE.Vector3();
let orbitRadius   = 2.5;
let orbitTheta    = Math.PI;
let orbitPhi      = Math.PI / 2.2;
let isDragging    = false;
let lastMouseX    = 0;
let lastMouseY    = 0;
let autoRotate    = true;

/* ─── Auto-frame ─── */
function autoFrame(idx) {
  const bb = characters[idx].bb;
  const size = new THREE.Vector3(
    bb.max[0] - bb.min[0],
    bb.max[1] - bb.min[1],
    bb.max[2] - bb.min[2]
  );
  const center = new THREE.Vector3(
    (bb.min[0] + bb.max[0]) / 2,
    (bb.min[1] + bb.max[1]) / 2,
    (bb.min[2] + bb.max[2]) / 2
  );

  const fov    = camera.fov * (Math.PI / 180);
  const aspect = camera.aspect;
  const effectiveWidth = Math.max(size.x, size.z);
  const vHalf  = size.y / 2;
  const hHalf  = effectiveWidth / (2 * aspect);
  const dominantHalf = Math.max(vHalf, hHalf);

  orbitRadius = dominantHalf / Math.tan(fov / 2) * 1.6;
  orbitTarget.set(center.x, center.y - size.y * 0.06, center.z);
  orbitTheta  = 0;  // front view (camera at +Z)
  orbitPhi    = Math.PI / 2.2;
}

/* ─── Apply orbit ─── */
function applyOrbit() {
  const sinPhi   = Math.sin(orbitPhi);
  const cosPhi   = Math.cos(orbitPhi);
  const sinTheta = Math.sin(orbitTheta);
  const cosTheta = Math.cos(orbitTheta);

  camera.position.set(
    orbitTarget.x + orbitRadius * sinPhi * sinTheta,
    orbitTarget.y + orbitRadius * cosPhi,
    orbitTarget.z + orbitRadius * sinPhi * cosTheta
  );
  camera.lookAt(orbitTarget);
}

/* ─── Mouse orbit controls ─── */
canvas.addEventListener('mousedown', (e) => {
  if (celebrationActive) return;
  isDragging  = true;
  autoRotate  = false;
  lastMouseX  = e.clientX;
  lastMouseY  = e.clientY;
  dragHint.classList.add('hidden');
});

window.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  const dx = e.clientX - lastMouseX;
  const dy = e.clientY - lastMouseY;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;

  orbitTheta -= dx * 0.008;
  orbitPhi   -= dy * 0.008;
  orbitPhi = Math.max(0.15, Math.min(Math.PI - 0.05, orbitPhi));
});

window.addEventListener('mouseup', () => {
  if (isDragging) {
    isDragging = false;
    setTimeout(() => { autoRotate = true; }, 1200);
  }
});

/* ─── Touch orbit ─── */
canvas.addEventListener('touchstart', (e) => {
  if (celebrationActive) return;
  if (e.touches.length === 1) {
    isDragging = true;
    autoRotate = false;
    lastMouseX = e.touches[0].clientX;
    lastMouseY = e.touches[0].clientY;
    dragHint.classList.add('hidden');
  }
}, { passive: true });

window.addEventListener('touchmove', (e) => {
  if (!isDragging || e.touches.length !== 1) return;
  const dx = e.touches[0].clientX - lastMouseX;
  const dy = e.touches[0].clientY - lastMouseY;
  lastMouseX = e.touches[0].clientX;
  lastMouseY = e.touches[0].clientY;

  orbitTheta -= dx * 0.008;
  orbitPhi   -= dy * 0.008;
  orbitPhi = Math.max(0.15, Math.min(Math.PI - 0.05, orbitPhi));
}, { passive: true });

window.addEventListener('touchend', () => {
  if (isDragging) {
    isDragging = false;
    setTimeout(() => { autoRotate = true; }, 1200);
  }
});

/* ─── Load models ─── */
async function loadModel(idx) {
  return new Promise((resolve, reject) => {
    loader.load(characters[idx].glb, (gltf) => {
      models[idx] = gltf.scene;
      // If user already navigated to this character while it was loading, show it now
      if (idx === current && !celebrationActive) showModel(idx);
      resolve();
    }, undefined, reject);
  });
}

async function loadAll() {
  try {
    await loadModel(0);
    showModel(0);
    await Promise.all([loadModel(1), loadModel(2)]);
  } catch (e) {
    console.error('Model load error:', e);
  }
}

/* ─── Swap model ─── */
function showModel(idx) {
  const existing = scene.getObjectByName('__activeModel');
  if (existing) scene.remove(existing);

  const model = models[idx];
  if (!model) {
    viewerLoader.classList.remove('hidden');
    return;
  }

  model.name = '__activeModel';
  scene.add(model);
  autoFrame(idx);
  applyOrbit();
  viewerLoader.classList.add('hidden');

  // Pause auto-rotate briefly so the front view is visible on switch
  autoRotate = false;
  setTimeout(() => { if (!celebrationActive && !isDragging) autoRotate = true; }, 1500);

  infoName.textContent = characters[idx].name;
  infoRole.textContent = characters[idx].role;
}

/* ─── Navigation ─── */
function goTo(idx) {
  if (idx === current || celebrationActive) return;
  current = idx;
  document.querySelectorAll('.char-card').forEach((c, i) => c.classList.toggle('active', i === current));
  if (models[current]) {
    showModel(current);
  } else {
    viewerLoader.classList.remove('hidden');
    infoName.textContent = characters[current].name;
    infoRole.textContent = characters[current].role;
  }
  document.getElementById('card-' + current).scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

function prev() { goTo((current - 1 + characters.length) % characters.length); }
function next() { goTo((current + 1) % characters.length); }

/* ─── Keyboard ─── */
document.addEventListener('keydown', (e) => {
  if (celebrationActive) return;
  if (e.key === 'ArrowUp')    { e.preventDefault(); prev(); }
  if (e.key === 'ArrowDown')  { e.preventDefault(); next(); }
  if (e.key === 'ArrowLeft')  { e.preventDefault(); prev(); }
  if (e.key === 'ArrowRight') { e.preventDefault(); next(); }
  if (e.key === 'Enter')      { e.preventDefault(); selectCharacter(); }
});

/* ─── Select button ─── */
document.getElementById('selectBtn').addEventListener('click', selectCharacter);

/* ─── Celebration state ─── */
let celebrationActive  = false;
let celebrationPending = false;
let celebrationStart   = 0;

// Saved pre-celebration orbit state
let savedTheta, savedPhi, savedRadius, savedTarget;

// Phase B: runs once the left panel has fully collapsed (or re-expanded)
function celebrationPhaseB() {
  celebrationPending = false;
  resizeRenderer();
  autoFrame(current);
  applyOrbit();
  savedTheta  = orbitTheta;
  savedPhi    = orbitPhi;
  savedRadius = orbitRadius;
  savedTarget = orbitTarget.clone();
  initCelebrationKeyframes();
  celebrationStart = performance.now();
}

function dismissResizeComplete() {
  resizeRenderer();
  autoFrame(current);
  applyOrbit();
  autoRotate = true;
}

panelLeft.addEventListener('transitionend', (e) => {
  if (e.propertyName !== 'flex-basis') return;
  if (celebrationPending) {
    celebrationPhaseB();
  } else if (!celebrationActive) {
    dismissResizeComplete();
  }
});

// Easing function
function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
function easeInOutCubic(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2; }

// Lerp helpers
function lerp(a, b, t) { return a + (b - a) * t; }
function lerpColor(a, b, t) {
  return new THREE.Color(
    lerp(a.r, b.r, t),
    lerp(a.g, b.g, t),
    lerp(a.b, b.b, t)
  );
}
function lerpVec3(a, b, t, out) {
  out.set(lerp(a.x, b.x, t), lerp(a.y, b.y, t), lerp(a.z, b.z, t));
  return out;
}

/* ─── Cinematic celebration timeline ─── */
// Shot 1: 0.30 – 0.90s  — low sweep out (epic rising angle)
// Shot 2: 0.90 – 1.60s  — whip orbit to back/side silhouette
// Shot 3: 1.60 – 2.40s  — rocket zoom into face close-up
// Shot 4: 2.40 – 3.20s  — pull back reveal full body, low heroic angle
// Shot 5: 3.20 – 3.80s  — ease into confident 3/4 front settle
// Lights lerp smoothly from default studio → cinematic over the flyby
// Title card: 3.80s+
// Auto-dismiss: 6.0s

const T_FLY_START   = 0.30;
const T_S1          = 0.90;   // shot 1 → 2
const T_S2          = 1.60;   // shot 2 → 3
const T_S3          = 2.40;   // shot 3 → 4
const T_S4          = 3.20;   // shot 4 → 5
const T_FLY_END     = 3.80;   // shot 5 end
const T_TITLE_START = 3.80;
const T_AUTO_DISMISS= 6.00;

/* ─── Cinematic light target (celebration end state) ─── */
const LIT_CINEMATIC = {
  key:     { intensity: 2.8, color: new THREE.Color(0xffffff) },
  fill:    { intensity: 0.6, color: new THREE.Color(0x6688cc) },  // cool blue
  rim:     { intensity: 1.2, color: new THREE.Color(0xffaa44) },  // warm orange rim
  ambient: { intensity: 0.3 }
};

/* ─── Per-shot end states (filled dynamically) ─── */
const SHOT1_END = { radius: 0, theta: 0, phi: 0, target: null };
const SHOT2_END = { radius: 0, theta: 0, phi: 0, target: null };
const SHOT3_END = { radius: 0, theta: 0, phi: 0, target: null };
const SHOT4_END = { radius: 0, theta: 0, phi: 0, target: null };
const SHOT5_END = { radius: 0, theta: 0, phi: 0, target: null };

function initCelebrationKeyframes() {
  const bb = characters[current].bb;
  const size = new THREE.Vector3(
    bb.max[0] - bb.min[0], bb.max[1] - bb.min[1], bb.max[2] - bb.min[2]
  );
  const center = new THREE.Vector3(
    (bb.min[0] + bb.max[0]) / 2, (bb.min[1] + bb.max[1]) / 2, (bb.min[2] + bb.max[2]) / 2
  );
  const bodyTarget  = new THREE.Vector3(center.x, center.y - size.y * 0.06, center.z);
  const headTarget  = new THREE.Vector3(center.x, center.y + size.y * 0.28, center.z);
  const chestTarget = new THREE.Vector3(center.x, center.y + size.y * 0.10, center.z);

  // Shot 1: sweep out to a low wide angle — camera drops and pulls back
  SHOT1_END.radius = savedRadius * 1.6;
  SHOT1_END.theta  = savedTheta - Math.PI * 0.25; // swing left
  SHOT1_END.phi    = Math.PI * 0.62;              // low camera looking up
  SHOT1_END.target = bodyTarget.clone();

  // Shot 2: whip around to back/side — big theta sweep, slight pull in
  SHOT2_END.radius = savedRadius * 1.2;
  SHOT2_END.theta  = SHOT1_END.theta + Math.PI * 0.7; // big swing around (126°)
  SHOT2_END.phi    = Math.PI * 0.48;                   // slightly above horizon
  SHOT2_END.target = chestTarget.clone();

  // Shot 3: rocket zoom tight on face — small radius, target up high
  SHOT3_END.radius = savedRadius * 0.38;
  SHOT3_END.theta  = SHOT2_END.theta + Math.PI * 0.15; // continue orbit slightly
  SHOT3_END.phi    = Math.PI * 0.44;                    // slightly above eye level
  SHOT3_END.target = headTarget.clone();

  // Shot 4: dramatic pull back — zoom out while staying low, reveal full body
  SHOT4_END.radius = savedRadius * 1.4;
  SHOT4_END.theta  = SHOT3_END.theta - Math.PI * 0.3; // swing back toward front
  SHOT4_END.phi    = Math.PI * 0.58;                   // low heroic angle
  SHOT4_END.target = bodyTarget.clone();

  // Shot 5: settle into confident 3/4 front pose
  SHOT5_END.radius = savedRadius * 1.0;
  SHOT5_END.theta  = savedTheta + Math.PI * 0.18; // slight 3/4 offset from front
  SHOT5_END.phi    = Math.PI / 2.2;               // normal eye-level
  SHOT5_END.target = bodyTarget.clone();
}

/* ─── Select → kick off celebration ─── */
function selectCharacter() {
  if (celebrationActive) return;
  celebrationActive  = true;
  celebrationPending = true;

  // Snap to front view (camera math correct; aspect & radius updated in Phase B)
  orbitTheta = 0;
  orbitPhi   = Math.PI / 2.2;
  applyOrbit();

  autoRotate  = false;
  isDragging  = false;

  // Flash
  flash.classList.add('show');
  setTimeout(() => flash.classList.remove('show'), 300);

  // Hide UI — panelLeft transition triggers Phase B via transitionend
  panelLeft.classList.add('hidden');
  viewerInfo.classList.add('hidden');
  hintRow.classList.add('hidden');
  dragHint.classList.add('hidden');

  // Safety fallback: if transitionend never fires (e.g. prefers-reduced-motion)
  setTimeout(() => { if (celebrationPending) celebrationPhaseB(); }, 500);
}

/* ─── Show celebration title card ─── */
let titleShown = false;

function showTitleCard(ch) {
  if (titleShown) return;
  titleShown = true;

  // Build letter spans with staggered delays
  celebName.innerHTML = '';
  const letters = ch.name.split('');
  letters.forEach((letter, i) => {
    const span = document.createElement('span');
    span.className = 'letter';
    span.textContent = letter === ' ' ? '\u00A0' : letter;
    span.style.animationDelay = (i * 0.045) + 's';
    celebName.appendChild(span);
  });

  // Set role — its animation delay is set relative to name completion
  celebRole.textContent = ch.role;
  const nameEndDelay = letters.length * 0.045;
  celebRole.style.animationDelay = nameEndDelay + 's';

  // Show overlay
  celebOverlay.classList.add('show');
}

/* ─── Dismiss celebration ─── */
function dismissCelebration() {
  celebOverlay.classList.remove('show');
  titleShown = false;

  // Restore lights to defaults
  applyLitState(LIGHTS_DEFAULT);

  // Restore orbit to front view (stale aspect is fine here; overlay is hiding)
  orbitTheta  = 0;
  orbitPhi    = Math.PI / 2.2;
  orbitRadius = savedRadius;
  orbitTarget.copy(savedTarget);
  applyOrbit();

  // Set celebrationActive = false BEFORE restoring panel so the
  // transitionend listener knows this is a dismiss re-expand
  celebrationActive = false;

  // Restore UI — panelLeft re-expand triggers resize via transitionend
  panelLeft.classList.remove('hidden');
  viewerInfo.classList.remove('hidden');
  hintRow.classList.remove('hidden');

  // Safety fallback: if transitionend never fires
  setTimeout(() => { if (!autoRotate) dismissResizeComplete(); }, 500);
}

/* ─── Dismiss on click/tap ─── */
celebOverlay.addEventListener('click', dismissCelebration);
celebOverlay.addEventListener('touchend', (e) => { e.preventDefault(); dismissCelebration(); });

/* ─── Animation loop ─── */
const ROTATE_SPEED = 0.5;
let lastTime = performance.now();

// Helper: apply a lighting state object to the scene lights
function applyLitState(state) {
  keyLight.intensity = state.key.intensity;
  keyLight.color.copy(state.key.color);
  fillLight.intensity = state.fill.intensity;
  fillLight.color.copy(state.fill.color);
  rimLight.intensity = state.rim.intensity;
  rimLight.color.copy(state.rim.color);
  ambientLight.intensity = state.ambient.intensity;
}

// Helper: lerp between two LIT_* states at parameter t, write result to scene lights
function lerpLitState(a, b, t) {
  keyLight.intensity  = lerp(a.key.intensity,  b.key.intensity,  t);
  keyLight.color.copy(lerpColor(a.key.color,   b.key.color,   t));
  fillLight.intensity = lerp(a.fill.intensity, b.fill.intensity, t);
  fillLight.color.copy(lerpColor(a.fill.color, b.fill.color, t));
  rimLight.intensity  = lerp(a.rim.intensity,  b.rim.intensity,  t);
  rimLight.color.copy(lerpColor(a.rim.color,   b.rim.color,   t));
  ambientLight.intensity = lerp(a.ambient.intensity, b.ambient.intensity, t);
}

function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt  = (now - lastTime) / 1000;
  lastTime  = now;

  if (celebrationActive) {
    const elapsed = (now - celebrationStart) / 1000; // seconds

    // ── Camera flyby + cinematic lighting ──
    if (elapsed >= T_FLY_START && elapsed < T_FLY_END) {

      // Smooth light transition over the entire flyby (default → cinematic)
      const lightT = easeInOutCubic(Math.min((elapsed - T_FLY_START) / (T_FLY_END - T_FLY_START), 1));
      lerpLitState(LIGHTS_DEFAULT, LIT_CINEMATIC, lightT);

      // ── Camera keyframes (5 shots) ──
      let camStart, camEnd, tStart, tEnd, easing;
      if (elapsed < T_S1) {
        camStart = { radius: savedRadius, theta: savedTheta, phi: savedPhi, target: savedTarget };
        camEnd   = SHOT1_END;  tStart = T_FLY_START; tEnd = T_S1;  easing = easeOutCubic;
      } else if (elapsed < T_S2) {
        camStart = SHOT1_END;  camEnd = SHOT2_END;   tStart = T_S1; tEnd = T_S2;  easing = easeInOutCubic;
      } else if (elapsed < T_S3) {
        camStart = SHOT2_END;  camEnd = SHOT3_END;   tStart = T_S2; tEnd = T_S3;  easing = easeInOutCubic;
      } else if (elapsed < T_S4) {
        camStart = SHOT3_END;  camEnd = SHOT4_END;   tStart = T_S3; tEnd = T_S4;  easing = easeInOutCubic;
      } else {
        camStart = SHOT4_END;  camEnd = SHOT5_END;   tStart = T_S4; tEnd = T_FLY_END; easing = easeInOutCubic;
      }
      const t = easing(Math.min((elapsed - tStart) / (tEnd - tStart), 1));
      orbitRadius = lerp(camStart.radius, camEnd.radius, t);
      orbitTheta  = lerp(camStart.theta,  camEnd.theta,  t);
      orbitPhi    = lerp(camStart.phi,    camEnd.phi,    t);
      lerpVec3(camStart.target, camEnd.target, t, orbitTarget);

      applyOrbit();
    }

    // ── Phase 4: Title card (2.80s+) ──
    if (elapsed >= T_TITLE_START) {
      showTitleCard(characters[current]);
    }

    // ── Phase 5: Auto dismiss ──
    if (elapsed >= T_AUTO_DISMISS) {
      dismissCelebration();
    }

  } else {
    // Normal mode: auto-rotate
    if (autoRotate) {
      orbitTheta -= ROTATE_SPEED * dt;
    }
    applyOrbit();
  }

  renderer.render(scene, camera);
}
animate();

/* ─── Resize ─── */
window.addEventListener('resize', () => {
  resizeRenderer();
  if (models[current]) {
    const bb = characters[current].bb;
    const size = new THREE.Vector3(bb.max[0]-bb.min[0], bb.max[1]-bb.min[1], bb.max[2]-bb.min[2]);
    const fov = camera.fov * (Math.PI / 180);
    const aspect = camera.aspect;
    const effectiveWidth = Math.max(size.x, size.z);
    const dominantHalf = Math.max(size.y/2, effectiveWidth/(2*aspect));
    orbitRadius = dominantHalf / Math.tan(fov/2) * 1.6;
  }
});

/* ─── Init ─── */
infoName.textContent = characters[0].name;
infoRole.textContent = characters[0].role;
loadAll();
</script>

</body>
</html>
